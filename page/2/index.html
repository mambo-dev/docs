<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/docs/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/docs/images/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/docs/images/favicon/favicon-16x16.png">
  <link rel="mask-icon" href="/docs/images/favicon/favicon.ico" color="#222">
  <meta name="google-site-verification" content="LMcddVW6xLBS7X1htGQ3duOIEmVp4ljku8sd3UuIcBg">

<link rel="stylesheet" href="/docs/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:300,300italic,400,400italic,700,700italic%7CNoto+Sans+KR:300,300italic,400,400italic,700,700italic%7CBinggrae-Bold:300,300italic,400,400italic,700,700italic%7CJetbrains+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mambo-dev.github.io","root":"/docs/","images":"/docs/images","scheme":"Gemini","version":"8.2.1","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"width":240,"scrollpercent":true,"b2t":true},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="Mambo Docs">
<meta property="og:url" content="https://mambo-dev.github.io/page/2/index.html">
<meta property="og:site_name" content="Mambo Docs">
<meta property="og:locale" content="ko_KR">
<meta property="article:author" content="Mambo">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://mambo-dev.github.io/page/2/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'ko'
  };
</script>
<title>Mambo Docs</title>
  
    <script>
      function sendPageView() {
        if (CONFIG.hostname !== location.hostname) return;
        var uid = localStorage.getItem('uid') || (Math.random() + '.' + Math.random());
        localStorage.setItem('uid', uid);
        navigator.sendBeacon('https://www.google-analytics.com/collect', new URLSearchParams({
          v  : 1,
          tid: 'UA-93954323-1',
          cid: uid,
          t  : 'pageview',
          dp : encodeURIComponent(location.pathname)
        }));
      }
      document.addEventListener('pjax:complete', sendPageView);
      sendPageView();
    </script>




  
  <script data-ad-client="ca-pub-9304279418886145" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/docs/atom.xml" title="Mambo Docs" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/docs/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Mambo Docs</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Mambo's development guide</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/docs/" rel="section"><i class="fas fa-home fa-fw"></i>홈</a></li>
        <li class="menu-item menu-item-archives"><a href="/docs/archives/" rel="section"><i class="fas fa-archive fa-fw"></i>아카이브<span class="badge">13</span></a></li>
        <li class="menu-item menu-item-스프링-프레임워크-가이드"><a href="/docs/categories/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EA%B0%80%EC%9D%B4%EB%93%9C/" rel="section"><i class="fas fa-book fa-fw"></i>스프링 프레임워크 가이드</a></li>
        <li class="menu-item menu-item-스프링-프레임워크-이야기"><a href="/docs/categories/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EC%9D%B4%EC%95%BC%EA%B8%B0/" rel="section"><i class="fas fa-book fa-fw"></i>스프링 프레임워크 이야기</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          목차
        </li>
        <li class="sidebar-nav-overview">
          흝어보기
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mambo"
      src="https://avatars1.githubusercontent.com/u/17937604?s=460&v=4">
  <p class="site-author-name" itemprop="name">Mambo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/docs/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">포스트</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">카테고리</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">태그</span>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/kdevkr" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kdevkr" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kdevkr@gmail.com" title="E-Mail → mailto:kdevkr@gmail.com" rel="noopener" target="_blank"><i class="fas fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.ko" class="cc-opacity" rel="noopener" target="_blank"><img src="/docs/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mambo-dev.github.io/configure-spring-web-application/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/17937604?s=460&v=4">
      <meta itemprop="name" content="Mambo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mambo Docs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/docs/configure-spring-web-application/" class="post-title-link" itemprop="url">스프링 웹 애플리케이션 구성 확장하기</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">작성일</span>

      <time title="Post created: 2020-09-12 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-12T00:00:00Z">2020-09-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/docs/categories/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EA%B0%80%EC%9D%B4%EB%93%9C/" itemprop="url" rel="index"><span itemprop="name">스프링 프레임워크 가이드</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>본 글은 스프링 프레임워크 Version <code>5.2.8.RELEASE</code> 문서를 기반으로 작성하였습니다.</p>
<p>지난 글에서 우리는 스프링 프레임워크 기반의 웹 애플리케이션을 만들고 임베디드 톰캣으로 웹 애플리케이션을 실행해보았습니다. 아직은 웹 애플리케이션에 대해 설정한 것이 없습니다. 그래서 이번에는 <a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/org.springframework/spring-webmvc/5.2.8.RELEASE"><code>spring-webmvc</code></a>에 포함된 <code>MVC Configuration</code>을 통해 웹 애플리케이션에 대한 설정을 확장해나가도록 하겠습니다.</p>
<h2 id="MVC-Configuration"><a href="#MVC-Configuration" class="headerlink" title="MVC Configuration"></a>MVC Configuration</h2><p>스프링 프레임워크에서 제공하는 MVC Configuration 기능을 활성화하기 위해서 <code>@EnableWebMvc</code>를 웹 애플리케이션 컨텍스트 메타 정보 클래스에 선언해야 합니다. @EnableWebMvc가 선언된 경우 애플리케이션 컨텍스트에 <code>WebMvcConfigurationSupport</code> 클래스가 자동으로 포함됩니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.example.demo.controller&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>사실 @EnableWebMvc으로 추가되는 클래스는 WebMvcConfigurationSupport를 확장한 <code>DelegatingWebMvcConfiguration</code>입니다. 이 클래스는 스프링 웹 MVC 애플리케이션을 위한 기본 구성을 제공하기도 하며 애플리케이션 컨텍스트에 존재하는 <code>WebMvcConfigurer</code> 구현체를 감지하여 설정을 변경할 수 있도록 위임합니다.</p>
<h3 id="MVC-Config-API"><a href="#MVC-Config-API" class="headerlink" title="MVC Config API"></a>MVC Config API</h3><p>스프링 웹 MVC에서 제공하는 설정은 <code>WebMvcConfigurer</code> 인터페이스를 통해 변경할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.example.demo.controller&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>WebMvcConfigurer 인터페이스에서 제공하는 함수를 통해 변경할 수 있는 기능에 대해서 하나씩 알아보도록 합시다.</p>
<h3 id="Validation"><a href="#Validation" class="headerlink" title="Validation"></a>Validation</h3><p>가장 먼저, <a target="_blank" rel="noopener" href="https://beanvalidation.org/"><code>Bean Validation</code></a>으로 도메인 모델에 대한 검증을 수행할 수 있도록 <code>Vailidator</code>에 대한 추상화를 지원합니다. </p>
<p>도메인 모델 검증을 위해 <code>hibernate-validator</code> 의존성을 추가합니다.</p>
<figure class="highlight groovy"><figcaption><span>build.gradle</span></figcaption><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.hibernate.validator:hibernate-validator:6.1.5.Final&#x27;</span></span><br><span class="line">implementation <span class="string">&#x27;org.hibernate.validator:hibernate-validator-annotation-processor:6.1.5.Final&#x27;</span></span><br></pre></td></tr></table></figure>

<p>기본적으로 클래스패스에 <code>Hibernate Validator</code>와 같은 Bean Validation 의존성이 포함되어있는 경우 전역 Validator로 <code>LocalValidatorFactoryBean</code>이 등록됩니다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-09-13 10:46:54 [main] INFO  o.h.v.i.util.Version(21) - HV000001: Hibernate Validator 6.1.5.Final</span><br><span class="line">2020-09-13 10:46:54 [main] DEBUG o.h.v.i.e.AbstractConfigurationImpl(203) - Setting custom ConstraintValidatorFactory of type org.springframework.validation.beanvalidation.SpringConstraintValidatorFactory</span><br><span class="line">2020-09-13 10:46:54 [main] DEBUG o.h.v.i.e.AbstractConfigurationImpl(217) - Setting custom ParameterNameProvider of type org.springframework.validation.beanvalidation.LocalValidatorFactoryBean$1</span><br><span class="line">2020-09-13 10:46:54 [main] DEBUG o.h.v.i.x.c.ValidationXmlParser(120) - Trying to load META-INF&#x2F;validation.xml for XML based Validator configuration.</span><br><span class="line">2020-09-13 10:46:54 [main] DEBUG o.h.v.i.x.c.ResourceLoaderHelper(53) - Trying to load META-INF&#x2F;validation.xml via user class loader</span><br><span class="line">2020-09-13 10:46:54 [main] DEBUG o.h.v.i.x.c.ResourceLoaderHelper(60) - Trying to load META-INF&#x2F;validation.xml via TCCL</span><br><span class="line">2020-09-13 10:46:54 [main] DEBUG o.h.v.i.x.c.ResourceLoaderHelper(66) - Trying to load META-INF&#x2F;validation.xml via Hibernate Validator&#39;s class loader</span><br><span class="line">2020-09-13 10:46:54 [main] DEBUG o.h.v.i.x.c.ValidationXmlParser(127) - No META-INF&#x2F;validation.xml found. Using annotation based configuration only.</span><br></pre></td></tr></table></figure>

<p>만약, 전역 Validator를 변경하고 싶은 경우 다음과 같이 <code>getValidator()</code>함수를 오버라이딩할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Validator <span class="title">getValidator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LocalValidatorFactoryBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Interceptors"><a href="#Interceptors" class="headerlink" title="Interceptors"></a>Interceptors</h3><p>디스패처 서블릿에 의해 처리가 위임된 웹 요청을 컨트롤러가 담당하기 전에 수행할 작업을 처리하는 것은 인터셉터라는 컴포넌트가 담당합니다. 스프링 웹 MVC는 특정 패턴에 대한 웹 요청에 대해서 인터셉터를 등록할 수 있도록 지원합니다.</p>
<p>인터셉터 등록은 <code>InterceptorRegistry</code>를 통해 가능합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> LocaleChangeInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그리고 특정 경로에 대해서만 인터셉터를 적용할 수도 있습니다. 예를 들어, 애플리케이션에서 제공하는 API에 대한 인증을 위해 토큰을 발급하고 검증을 확인하는 작업을 수행할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">registry.addInterceptor(<span class="keyword">new</span> HandlerInterceptorAdapter() &#123;&#125;).addPathPatterns(<span class="string">&quot;/api/**&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>좀 더 응용하여 웹 요청에 대한 보안을 체크하는 로직이나 처리를 담당하는 컨트롤러의 핸들러 함수가 View를 응답하는 경우에 Model에 공통된 값을 주입하기 위한 작업을 수행할 수 있습니다.</p>
</blockquote>
<h3 id="MessageConverters"><a href="#MessageConverters" class="headerlink" title="MessageConverters"></a>MessageConverters</h3><p>스프링 프레임워크는 컨트롤러의 핸들러 함수에 <code>@ResponseBody</code>가 선언되어 있다면 반환되는 객체를 메시지로 변환하여 응답하기 위한 작업을 수행합니다. 예를 들어, <code>Map</code> 형식을 <code>JSON</code> 형식의 메시지로 변경하기 위해서 <code>ObjectMapper</code>를 사용하는 <code>MappingJackson2HttpMessageConverter</code>를 사용하도록 설정할 수 있습니다.  </p>
<p>우선 아무런 설정 없이 컨트롤러 핸들러 함수에 @ResponseBody를 선언하고 Map 객체를 반환하도록 해보겠습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/json&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">json</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; body = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    body.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그러면 다음과 같이 기본적으로 Map 형식에 대한 메시지 컨버터가 없으므로 다음과 같은 오류가 발생합니다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.http.converter.HttpMessageNotWritableException: No converter found for return value of type: class java.util.HashMap</span><br><span class="line">	org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor.writeWithMessageConverters(AbstractMessageConverterMethodProcessor.java:230)</span><br><span class="line">	org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.handleReturnValue(RequestResponseBodyMethodProcessor.java:181)</span><br><span class="line">	org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite.handleReturnValue(HandlerMethodReturnValueHandlerComposite.java:82)</span><br><span class="line">	org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:123)</span><br><span class="line">	org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:878)</span><br><span class="line">	org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:792)</span><br><span class="line">	org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)</span><br><span class="line">	org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)</span><br><span class="line">	org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)</span><br><span class="line">	org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)</span><br><span class="line">	org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898)</span><br><span class="line">	javax.servlet.http.HttpServlet.service(HttpServlet.java:645)</span><br><span class="line">	org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)</span><br><span class="line">	javax.servlet.http.HttpServlet.service(HttpServlet.java:750)</span><br></pre></td></tr></table></figure>

<p>그러면 Map으로 반환하는 것을 JSON 형식의 메시지로 변환하여 응답하도록 메시지 컨버터를 추가해보겠습니다.</p>
<p><a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind/2.11.2"><code>jackson-databind</code></a> 의존성을 추가합니다. </p>
<figure class="highlight groovy"><figcaption><span>build.gradle</span></figcaption><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.fasterxml.jackson.core:jackson-databind:2.11.2&#x27;</span></span><br></pre></td></tr></table></figure>

<p>클래스패스에 <code>jackson-databind</code> 의존성이 포함되면 자동으로 <code>MappingJackson2HttpMessageConverter</code>가 메시지 컨버터로 등록됩니다. 이제 MappingJackson2HttpMessageConverter에 의해 Map 형식이 JSON 형식의 문자열로 변환되어 응답됩니다.</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;message&quot;</span>:<span class="string">&quot;Hello World&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>그리고 <code>configureMessageConverters()</code> 함수를 통해 메시지 컨버터를 등록할 수 있습니다. 예를 들어, MappingJackson2HttpMessageConverter에서 사용하는 <code>ObjectMapper</code>를 변경할 수 도 있습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">        Jackson2ObjectMapperBuilder objectMapperBuilder = <span class="keyword">new</span> Jackson2ObjectMapperBuilder()</span><br><span class="line">                .indentOutput(<span class="keyword">true</span>);</span><br><span class="line">        converters.add(<span class="keyword">new</span> MappingJackson2HttpMessageConverter(objectMapperBuilder.build()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 예제 코드에서 ObjectMapper의 <code>indentOutput</code> 속성을 활성화하였으므로 다음과 같이 응답 메시지가 출력됩니다.</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;message&quot;</span> : <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="View-Resolvers"><a href="#View-Resolvers" class="headerlink" title="View Resolvers"></a>View Resolvers</h3><p>지난 글에서 프리마커 템플릿 엔진을 사용하여 HTML을 응답하기 위해 FreeMarkerViewResolver를 빈 클래스로 등록하였습니다. MVC Configuration에서 제공하는 <code>configureViewResolvers()</code>함수를 통해 좀더 쉽게 FreeMarkerViewResolver를 빈으로 등록할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.freeMarker()</span><br><span class="line">                .cache(<span class="keyword">false</span>)</span><br><span class="line">                .suffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>클래스패스에 <a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind/2.11.2"><code>jackson-databind</code></a>이 포함되면 <code>ContentNegotiatingViewResolver</code>가 JSON 형식의 메시지를 처리할 수 있도록 <code>MappingJackson2JsonView</code>를 등록합니다.</p>
<p>ContentNegotiatingViewResolver는 웹 요청 경로에 확장자가 표현되는 경우 해당 형식으로 응답할 수 있도록 지원합니다. 예를 들어, <code>.json</code>으로 끝나는 요청에 대하여 MappingJackson2JsonView으로 응답하는 것을 말합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.enableContentNegotiation(<span class="keyword">new</span> MappingJackson2JsonView());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Static-Resources"><a href="#Static-Resources" class="headerlink" title="Static Resources"></a>Static Resources</h3><p>때때로, 웹 애플리케이션에서는 자바스크립트, 스타일시트 또는 이미지 파일과 같은 <code>정적 리소스</code>를 제공해야할 수 있습니다. 그리고 이 정적 리소스는 사용자 또는 응답한 HTML에서 요구할 가능성이 있습니다.</p>
<p>스프링 MVC Configuration는 정적 리소스를 처리할 수 있도록 <code>Resource Handler</code>를 지원합니다.</p>
<p>리소스 핸들러 등록은 <code>addResourceHandlers()</code>함수에서 <code>ResourceHandlerRegistry</code>를 통해 가능합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/images/**&quot;</span>, <span class="string">&quot;/css/**&quot;</span>, <span class="string">&quot;/js/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;classpath:/static/images/&quot;</span>, <span class="string">&quot;classpath:/static/css/&quot;</span>, <span class="string">&quot;classpath:/static/js/&quot;</span>)</span><br><span class="line">                .setCacheControl(CacheControl.maxAge(Duration.ofDays(<span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위와 같이 설정된 경우 <code>/images</code>, <code>/css</code>, <code>/js</code>로 시작되는 요청은 리소스 핸들러가 담당하도록 처리되며 리소스 핸들러가 찾아야할 리소스의 위치는 클래스패스에 있는 <code>static</code> 폴더입니다.</p>
<p>다음과 같이 <a target="_blank" rel="noopener" href="http://localhost:8080/images/snorlax.jpg">http://localhost:8080/images/snorlax.jpg</a> 요청에 대해 <code>static/images/snorlax.jpg</code> 경로의 파일을 찾아 응답하게 됩니다.</p>
<p><img data-src="/images/posts/spring5-002.PNG"></p>
<h2 id="Advanced-MVC-Configuration"><a href="#Advanced-MVC-Configuration" class="headerlink" title="Advanced MVC Configuration"></a>Advanced MVC Configuration</h2><p>스프링 프레임워크 기반의 웹 애플리케이션을 위해 도움이 되는 몇가지 설정에 대해 알아보겠습니다.</p>
<h3 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h3><p><code>spring-web</code> 모듈은 웹 애플리케이션에서 활용할 수 있는 유용한 필터 클래스들을 제공합니다.</p>
<h4 id="FormContentFilter"><a href="#FormContentFilter" class="headerlink" title="FormContentFilter"></a>FormContentFilter</h4><p>브라우저는 기본적으로 HTTP.GET 또는 HTTP.POST을 통해 폼 데이터를 전송합니다. 브라우저가 아닌 클라이언트들은 PUT, PATCH, DELETE를 HTTP 메소드로도 사용할 수 있습니다. 그런데 Servlet API는 <code>ServletRequest.getParameter*()</code>가 HTTP POST에 대해서만 접근할 수 있도록 허용합니다.</p>
<p><code>spring-web</code> 모듈에서 제공하는 <code>FormContentFilter</code>는 <code>application/x-www-form-urlencoded</code>를 컨텐트 타입으로 요청하는 PUT, PATH, DELETE에 대해서 요청 바디를 폼 데이터로 읽을 수 있도록 <code>ServletRequest</code>에 대해 랩핑을 지원합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FormContentFilter <span class="title">formContentFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FormContentFilter formContentFilter = <span class="keyword">new</span> FormContentFilter();</span><br><span class="line">    formContentFilter.setCharset(StandardCharsets.UTF_8);</span><br><span class="line">    formContentFilter.setFormConverter(<span class="keyword">new</span> FormHttpMessageConverter());</span><br><span class="line">    <span class="keyword">return</span> formContentFilter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ForwardedHeaderFilter"><a href="#ForwardedHeaderFilter" class="headerlink" title="ForwardedHeaderFilter"></a>ForwardedHeaderFilter</h4><p>로드 밸런서와 같이 프록시를 통해 들어오는 요청은 호스트, 포트 그리고 스키마가 변경될 가능성이 있습니다. 이에 스프링 웹 모듈에서 제공하는 <code>ForwardedHeaderFilter</code>는 RFC 7239로 정의된 <code>Forwared HTTP Header</code>에 대해서 본래의 요청 정보를 제공합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ForwardedHeaderFilter <span class="title">forwardedHeaderFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForwardedHeaderFilter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>스프링 웹 MVC는 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/ko/docs/Web/HTTP/CORS"><code>CORS(Cross-Origin Resource Sharing)</code></a>를 처리할 수 있도록 지원합니다. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/api/**&quot;</span>)</span><br><span class="line">                .allowedMethods(HttpMethod.GET.name(), HttpMethod.POST.name(), HttpMethod.PUT.name(), HttpMethod.DELETE.name())</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .maxAge(Duration.ofHours(<span class="number">1</span>).toSeconds());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HTTP-Caching"><a href="#HTTP-Caching" class="headerlink" title="HTTP Caching"></a>HTTP Caching</h3><p>HTTP 캐시는 웹 애플리케이션 성능을 향상시킬 수 있는 기능입니다. HTTP 캐시는 <code>Cache-Control</code> 응답 헤더와 함께 <code>Last-Modified</code>와 <code>ETag</code>와 같은 요청 헤더에 의해 이루어집니다. 스프링 프레임워크에서는 CacheControl를 통해 캐시 정책을 나타낼수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CacheControl cacheControl = CacheControl.maxAge(<span class="number">1</span>, TimeUnit.DAYS).noTransform().cachePublic();</span><br></pre></td></tr></table></figure>

<p>스프링 컨트롤러는 <code>ResponseEntity</code>를 통해 <code>CacheControl</code>을 적용할 수 있도록 지원합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/health&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Object&gt; <span class="title">health</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity</span><br><span class="line">                .ok()</span><br><span class="line">                .cacheControl(CacheControl</span><br><span class="line">                                .maxAge(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">                                .cachePublic()</span><br><span class="line">                                .noTransform())</span><br><span class="line">                .body(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>눈치채지 못하셨을수도 있겠지만 <code>리소스 핸들러</code>를 등록할 때에도 캐시 정책을 지정하였습니다.</p>
</blockquote>
<h3 id="Web-Security"><a href="#Web-Security" class="headerlink" title="Web Security"></a>Web Security</h3><p>스프링 프레임워크는 보안 관련 기능을 <code>Spring Security</code> 프로젝트를 통해 제공합니다. 웹 보안과 관련된 부분은 스프링 시큐리티 모듈에 대한 글을 통해 알아보도록 합니다.</p>
<hr>
<p>스프링 프레임워크 기반의 웹 애플리케이션을 위한 기본적인 설정이나 기능에 대해서 추가해보았습니다. 앞으로는 웹 애플리케이션의 목표인 다음과 같은 것들을 적용하는 방법에 대해 다루도록 하겠습니다.</p>
<ul>
<li>스프링 테스트 모듈을 통한 애플리케이션 기능 테스트</li>
<li>웹 관련 기능 확장</li>
<li>구글 SMTP 서버를 활용한 이메일 발송</li>
<li>반복적인 작업을 수행하는 스케줄링 적용</li>
<li>스프링 JDBC를 활용한 데이터베이스 액세스</li>
<li>스프링 HTTP 요청 클라이언트 활용</li>
<li>스프링 세션을 활용한 사용자 세션 관리 적용</li>
<li>스프링 시큐리티를 활용한 웹 보안 적용</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mambo-dev.github.io/building-web-application-with-spring-framework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/17937604?s=460&v=4">
      <meta itemprop="name" content="Mambo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mambo Docs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/docs/building-web-application-with-spring-framework/" class="post-title-link" itemprop="url">스프링 웹 애플리케이션 만들기</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">작성일</span>

      <time title="Post created: 2020-09-11 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-11T00:00:00Z">2020-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/docs/categories/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EA%B0%80%EC%9D%B4%EB%93%9C/" itemprop="url" rel="index"><span itemprop="name">스프링 프레임워크 가이드</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>본 글은 스프링 프레임워크 Version <code>5.2.8.RELEASE</code> 문서를 기반으로 작성하였습니다.</p>
<p>지난 글에서 우리는 스프링 프레임워크의 기본이 되는 개념인 IoC 컨테이너라는 애플리케이션 컨텍스트에 대해 배웠습니다. 이번 글에서는 스프링 프레임워크 기반의 웹 애플리케이션을 구성하고 실행하는 방법에 대해서 다루겠습니다.</p>
<h2 id="Web-on-Servlet-Stack"><a href="#Web-on-Servlet-Stack" class="headerlink" title="Web on Servlet Stack"></a>Web on Servlet Stack</h2><p>스프링 5 부터 웹 애플리케이션이 동작하는 방식이 기존의 서블릿 API를 사용하는 서블릿 스택과 <a target="_blank" rel="noopener" href="https://www.reactive-streams.org/">Reactive Streams</a> 스펙 기반의 <a target="_blank" rel="noopener" href="https://projectreactor.io/">리액티브</a> 스택이 있습니다. 리액티브 스택은 블로킹 기반의 서블릿 스택과 달리 논-블로킹이라는 특징이 있습니다. 리액티브 스택의 웹 애플리케이션을 개발하기 위해서는 우선적으로 비동기 프로그래밍을 배워야하므로 많은 개발자들에게 익숙한 서블릿 스택 기반의 웹 애플리케이션을 만들어보도록 합니다.</p>
<p>서블릿 스택 기반의 웹 애플리케이션을 만들기 위해 <a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/org.springframework/spring-webmvc/5.2.8.RELEASE"><code>spring-webmvc</code></a>와 <code>javax.servlet-api</code> 의존성을 추가합니다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.springframework:spring-webmvc:5.2.8.RELEASE&#x27;</span></span><br><span class="line">implementation <span class="string">&#x27;javax.servlet:javax.servlet-api:4.0.1&#x27;</span></span><br></pre></td></tr></table></figure>

<p>자바 웹 애플리케이션을 Tomcat과 같은 웹 컨테이너를 통해 실행할 경우 웹 컨테이너는 클래스패스에 위치한 <a target="_blank" rel="noopener" href="https://cloud.google.com/appengine/docs/flexible/java/configuring-the-web-xml-deployment-descriptor?hl=ko"><code>web.xml</code></a>이라는 배포 설명자 파일을 참조합니다. 스프링 프레임워크의 <code>spring-web</code> 모듈에는 배포 설명자 파일인 web.xml을 자바 코드로 대체할 수 있는 특별한 인터페이스를 제공합니다.</p>
<h3 id="WebApplicationInitializer"><a href="#WebApplicationInitializer" class="headerlink" title="WebApplicationInitializer"></a>WebApplicationInitializer</h3><p>웹 컨테이너에서 가장 먼저 참조하는 배포 설명자를 구성하기 위하여 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/javadoc-api/org/springframework/web/WebApplicationInitializer.html"><code>WebApplicationInitializer</code></a> 인터페이스에 대한 구현체를 생성할 수 있습니다.</p>
<p>웹 컨테이너가 실행될 때 클래스패스에 위치한 web.xml 파일이 존재하지 않을 경우 WebApplicationInitializer를 감지하여 web.xml로 대체하여 사용하게 됩니다. 정말로 WebApplicationInitializer로 web.xml을 대체할 수 있는지 확인해봅시다.</p>
<p>우선 다음과 같이 WebApplicationInitializer 구현체를 클래스패스에 생성합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebServletInitializer</span> <span class="title">implementation</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigWebApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigWebApplicationContext();</span><br><span class="line">        applicationContext.setConfigLocation(<span class="string">&quot;com.example.demo.config&quot;</span>);</span><br><span class="line">        servletContext.addListener(<span class="keyword">new</span> ContextLoaderListener(applicationContext));</span><br><span class="line">        ServletRegistration.Dynamic dispatcher = servletContext.addServlet(<span class="string">&quot;dispatcher&quot;</span>, <span class="keyword">new</span> DispatcherServlet(applicationContext));</span><br><span class="line">        dispatcher.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        dispatcher.addMapping(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 자바 코드는 아래의 web.xml을 기술한 것과 같다고 볼 수 있습니다.</p>
<figure class="highlight xml"><figcaption><span>web.xml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">version</span>=<span class="string">&quot;2.5&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee  http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring/application-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">       <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring/application-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">              </span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>위 예제는 <code>단일 애플리케이션 컨텍스트</code>로 동작하는 웹 애플리케이션을 구성합니다. 그러나 대부분의 web.xml에 대한 예제를 찾아보면 <code>루트 애플리케이션 컨텍스트</code>와 디스패처 서블릿이 참조하는 <code>서블릿 컨텍스트</code>를 구분하여 구성한 것이 많습니다. 스프링 프레임워크는 단일 애플리케이션 컨텍스트 구조 뿐만 아니라 루트 애플리케이션 컨텍스트와 서블릿 애플리케이션 컨텍스트를 나누어 컨텍스트 계층을 구성할 수 있는 특별한 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 클래스를 제공합니다.</p>
<p>AbstractAnnotationConfigDispatcherServletInitializer가 클래스패스에 위치하는 경우 다음과 같은 구조로 웹 애플리케이션을 구성할 수 있습니다.<br><img data-src="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/images/mvc-context-hierarchy.png"></p>
<p>위 그림은 스프링 프레임워크 공식 레퍼런스에서 제공하는 <code>다중 컨텍스트 계층</code>을 표현합니다. 웹과 관련된 빈 클래스들은 서블릿 웹 애플리케이션 컨텍스트에서 관리되며 루트 애플리케이션 컨텍스트에는 웹과 관련이 없거나 공통적으로 사용되는 빈 클래스들을 관리하도록 합니다.</p>
<p>다음 예제 코드는 AbstractAnnotationConfigDispatcherServletInitializer를 적용하는 예시입니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebServletInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[] &#123; AppConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[] &#123; WebConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>루트 애플리케이션 컨텍스트가 참조하는 구성 메타정보는 <code>getRootConfigClasses</code>에서 반환합니다. 그리고 서블릿 애플리케이션 컨텍스트에서 참조하는 구성 메타정보는 <code>getServletConfigClasses</code>에서 반환합니다. 따라서, 위 예제 코드에서는 루트 애플리케이션 컨텍스트는 AppConfig 클래스에 등록된 빈 클래스들을 관리하게 되고 WebConfig 클래스에 등록된 빈 클래스들은 서블릿 애플리케이션 컨텍스트를 통해 관리됩니다. </p>
<blockquote>
<p>이때 만들어지는 디스패처 서블릿은 dispatcher라는 이름을 기본으로 사용합니다.</p>
</blockquote>
<p>따라서, 다중 애플리케이션 컨텍스트 계층으로 웹 애플리케이션을 구성한다면 루트 애플리케이션 컨텍스트와 서블릿 애플리케이션 컨텍스트에서 관리해야할 빈들을 잘 구분하여 등록하여 사용하는 것이 좋습니다.</p>
<p>이제 웹 컨테이너에서 읽어야할 배포 설명자인 WebApplicationInitializer가 준비되었으므로 웹 애플리케이션을 구동할 수 있습니다. 저는 임베디드 톰캣 모듈을 통하여 쉽게 애플리케이션을 구동하는 방법을 설명하도록 하겠습니다.</p>
<h3 id="Embedded-Tomcat"><a href="#Embedded-Tomcat" class="headerlink" title="Embedded Tomcat"></a>Embedded Tomcat</h3><p>임베디드 톰캣으로 애플리케이션을 실행하기 위하여 <code>tomcat-embed-core</code>와 <code>tomcat-embed-jasper</code> 의존성을 추가합니다.</p>
<figure class="highlight groovy"><figcaption><span>build.gradle</span></figcaption><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.apache.tomcat.embed:tomcat-embed-core:9.0.37&#x27;</span></span><br><span class="line">implementation <span class="string">&#x27;org.apache.tomcat.embed:tomcat-embed-jasper:9.0.37&#x27;</span></span><br></pre></td></tr></table></figure>

<p>SpringApplication에서 톰캣 서버를 실행하도록 다음과 같이 코드를 작성합니다. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">        Tomcat tomcat = <span class="keyword">new</span> Tomcat();</span><br><span class="line">        tomcat.setBaseDir(<span class="string">&quot;out/webapp&quot;</span>);</span><br><span class="line">        Connector connector = tomcat.getConnector();</span><br><span class="line">        connector.setURIEncoding(StandardCharsets.UTF_8.displayName());</span><br><span class="line"></span><br><span class="line">        tomcat.addWebapp(<span class="string">&quot;&quot;</span>, <span class="keyword">new</span> File(<span class="string">&quot;src/main/webapp&quot;</span>).getAbsolutePath());</span><br><span class="line">        tomcat.setPort(<span class="number">8080</span>);</span><br><span class="line">        tomcat.start();</span><br><span class="line">        tomcat.getServer().await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제 SpringApplication을 실행하고 로그를 확인합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="number">9</span>월 <span class="number">11</span>, <span class="number">2020</span> <span class="number">10</span>:<span class="number">39</span>:<span class="number">10</span> 오후 org.apache.catalina.startup.ContextConfig getDefaultWebXmlFragment</span><br><span class="line">정보: No global web.xml found</span><br><span class="line"><span class="number">9</span>월 <span class="number">11</span>, <span class="number">2020</span> <span class="number">10</span>:<span class="number">39</span>:<span class="number">11</span> 오후 org.apache.catalina.core.ApplicationContext log</span><br><span class="line">정보: <span class="number">1</span> Spring WebApplicationInitializers detected on classpath</span><br><span class="line">...</span><br><span class="line"><span class="number">9</span>월 <span class="number">11</span>, <span class="number">2020</span> <span class="number">10</span>:<span class="number">39</span>:<span class="number">12</span> 오후 org.apache.coyote.AbstractProtocol start</span><br><span class="line">정보: Starting ProtocolHandler [<span class="string">&quot;http-nio-8080&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>출력된 로그를 살펴보면 Spring WebApplicationInitializers detected on classpath 에서 확인할 수 있듯이 클래스패스에 있는 WebApplicationInitializer를 web.xml으로 사용하였습니다.</p>
<p>톰캣이 웹 애플리케이션을 정상적으로 구동하였으므로 브라우저를 통해 <a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a> 로 접속해보겠습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">경고: No mapping <span class="keyword">for</span> GET /</span><br></pre></td></tr></table></figure>

<p>이런… 디스패처 서블릿이 처리를 위임할 서블릿을 찾을 수 없어 경고 메시지가 출력되었고 브라우저에서는 응답 없음을 확인할 수 있습니다. 이제 우리가 알아야할 것은 웹 요청을 처리할 서블릿을 스프링 프레임워크가 제공하는 클래스로 구성하는 것입니다.</p>
<h3 id="Annotated-Controllers"><a href="#Annotated-Controllers" class="headerlink" title="Annotated Controllers"></a>Annotated Controllers</h3><p>스프링 웹 MVC 모듈은 웹 요청을 처리할 컴포넌트를 만들 수 있는 어노테이션을 제공합니다. 스프링 프레임워크에서 웹 요청을 처리하는 컴포넌트를 컨트롤러라고 합니다. 그리고 컨트롤러라는 것을 <code>@Controller</code>와 <code>@RestController</code>를 선언하여 나타낼 수 있습니다. </p>
<p>컨트롤러는 웹 관련 빈 클래스이므로 서블릿 웹 애플리케이션 컨텍스트의 구성 메타정보인 <code>WebConfig</code>에 등록하겠습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.example.demo.controller&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>@ComponentScan</code>을 선언하였으므로 <code>com.example.demo.controller</code> 패키지에 있는 컨트롤러 컴포넌트들은 서블릿 애플리케이션 컨텍스트에서 관리됩니다. </p>
<p>다음과 같이 <code>HomeController</code>라는 컨트롤러를 만들어 웹 요청을 처리할 <code>핸들러 함수</code>를 만들겠습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">home</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PrintWriter writer = response.getWriter();</span><br><span class="line">        writer.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제 SpringApplication을 실행하면 디스패처 서블릿이 웹 요청에 대해 처리할 컨트롤러를 찾아 위임하여 HTTP 요청을 처리하고 응답을 받게됩니다. </p>
<p><code>Hello World</code>라는 문자열이 브라우저에 표시되었나요?</p>
<p>대부분의 스프링 애플리케이션 예제와 달리 컨트롤러의 핸들러 함수에서 “Hello World”를 반환하지 않는지 궁금해 해야합니다. 저는 어떤 지식을 공부할 때에는 궁금한게 많아야한다고 생각하는 편입니다. 왜 HttpServletResponse에서 <code>PrintWriter</code>를 가져와 문자열을 출력했는지는 공식 레퍼런스를 살펴보면 찾을 수 있습니다.</p>
<p>우선 컨트롤러 컴포넌트를 만들때 사용하는 것들에 대해 알아보면서 설명하겠습니다.</p>
<h4 id="Request-Mapping"><a href="#Request-Mapping" class="headerlink" title="Request Mapping"></a>Request Mapping</h4><p>가장 먼저 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping"><code>@RequestMapping</code></a>은 선언된 핸들러 함수가 어떻게 웹 요청을 처리할지 결정할 수 있습니다. 예를 들어, 특정 URL, 파라미터, 헤더, 미디어 타입에 따라 처리할 요청을 구분할 수 있습니다. 위 예제에서 선언된 <code>@GetMapping</code>은 이 @RequestMapping에 대해 HTTP 메소드에 따라 확장한 어노테이션 중 하나입니다.</p>
<ul>
<li>@GetMapping</li>
<li>@PostMapping</li>
<li>@PutMapping</li>
<li>@DeleteMapping</li>
</ul>
<p>만약, 컨트롤러에서 처리하는 함수가 여러가지 HTTP 메소드를 지원하는 경우가 아니라면 HTTP 메소드에 따라 확장된 어노테이션을 선언하는 것이 가독성에 이점이 있습니다.</p>
<h4 id="Handler-Methods"><a href="#Handler-Methods" class="headerlink" title="Handler Methods"></a>Handler Methods</h4><p>컨트롤러에 선언된 핸들러 함수는 여러가지 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/web.html#mvc-ann-arguments">매개변수</a>를 지정할 수 있습니다.</p>
<p>위 예제 코드에서 HttpServletRequest와 HttpServletResponse도 매개변수로 받을 수 있는 클래스 중 하나입니다. </p>
<h4 id="Return-Values"><a href="#Return-Values" class="headerlink" title="Return Values"></a>Return Values</h4><p>앞서 핸들러 함수에서 void 형식을 반환한 이유를 여기서 확인할 수 있습니다. 컨트롤러의 핸들러 함수는 반환할 수 있는 형식이 정해져 있습니다. 예를 들어, 컨트롤러에 선언된 핸들러 함수가 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/web.html#mvc-ann-return-types">반환하는 유형</a> 중 <code>String</code>은 문자열을 응답하는 것이 아니라 스프링 프레임워크에서 사용하는 <code>뷰(View)</code>라는 응답 객체의 이름을 지정하는 것으로 정해져있습니다. </p>
<p>따라서, “Hello World”라는 문자열을 응답으로 출력 위하여 String 형식으로 반환하였다면 디스패처 서블릿은 응답을 위해 Hello Wolrd라는 이름을 가진 뷰를 찾게됩니다. 디스패처 서블릿은 결국 요청을 처리할 수 없다고 판단합니다.</p>
<p>다음 처럼 말이죠.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">경고: No mapping <span class="keyword">for</span> GET /Hello World</span><br></pre></td></tr></table></figure>

<p>스프링 웹 MVC는 핸들러 함수에서 반환하는 유형에 따라 응답해야하는 것을 구분하기 위하여 <code>ViewResolver</code> 인터페이스를 통해 수행합니다. 기본적으로 ViewResolver에 대한 설정이 존재하지 않으면 <code>InternalResourceViewResolver</code>를 사용하게 됩니다. 여기서 확인할 수 있는 점은 우리가 원하는 형식으로 응답하기 위해서는 ViewResolver에 대한 설정을 해야한다는 것입니다.</p>
<p>다음의 ViewResolver에 대해서 찾아보시기를 추천합니다.</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.2.8.RELEASE/javadoc-api/org/springframework/web/servlet/view/ContentNegotiatingViewResolver.html">ContentNegotiatingViewResolver</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.2.8.RELEASE/javadoc-api/org/springframework/web/servlet/view/InternalResourceViewResolver.html">InternalResourceViewResolver</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.2.8.RELEASE/javadoc-api/org/springframework/web/servlet/view/freemarker/FreeMarkerViewResolver.html">FreeMarkerViewResolver</a></li>
</ul>
<h2 id="Template-Engine"><a href="#Template-Engine" class="headerlink" title="Template Engine"></a>Template Engine</h2><p>위에서 언급한 ViewResolver 중 <code>FreeMarkerViewResolver</code>는 프리마커 템플릿 엔진을 사용하여 HTML을 응답하기 위한 설정을 할 때 사용할 수 있습니다. 웹 애플리케이션의 목표는 웹 요청을 처리하여 응답하는 것이며 HTML 형식으로 응답하는 것은 중요한 부분입니다.</p>
<p>스프링 웹 MVC에서 기본적으로 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.2.8.RELEASE/javadoc-api/org/springframework/web/servlet/view/InternalResourceViewResolver.html"><code>InternalResourceViewResolver</code></a>을 사용하여 뷰를 응답한다고 하였습니다. 이 InternalResourceViewResolver는 UrlBasedViewResolver를 확장한 클래스로 Servlet이나 JSP와 같은 <code>InternalResourceView</code> 또는 <code>JstlView</code>를 응답으로 사용하게 됩니다.</p>
<p>예를 들어, 다음과 같이 컨트롤러 핸들러 함수에서 <code>index</code>라는 뷰 이름을 반환합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그러면 InternalResourceViewResolver에 의해 InternalResourceView로 판단하고 <code>/index</code>라는 경로로 요청이 <code>포워딩</code> 됩니다.</p>
<blockquote>
<p>여기서 포워딩 되는 이유는 InternalResourceViewResolver가 UrlBasedViewResolver를 기반으로 하기 때문입니다.</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">2020-09-13 08:19:33 [http-nio-8080-exec-1] DEBUG o.s.w.s.DispatcherServlet(91) - GET <span class="string">&quot;/&quot;</span>, parameters=&#123;&#125;</span><br><span class="line">2020-09-13 08:19:33 [http-nio-8080-exec-1] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping(414) - Mapped to com.example.demo.controller.HomeController<span class="comment">#index(HttpServletRequest, HttpServletResponse)</span></span><br><span class="line">2020-09-13 08:19:33 [http-nio-8080-exec-1] DEBUG o.s.w.s.v.InternalResourceView(309) - View name <span class="string">&#x27;index&#x27;</span>, model &#123;&#125;</span><br><span class="line">2020-09-13 08:19:33 [http-nio-8080-exec-1] DEBUG o.s.w.s.v.InternalResourceView(169) - Forwarding to [index]</span><br><span class="line">2020-09-13 08:19:33 [http-nio-8080-exec-1] DEBUG o.s.w.s.DispatcherServlet(91) - <span class="string">&quot;FORWARD&quot;</span> dispatch <span class="keyword">for</span> GET <span class="string">&quot;/index&quot;</span>, parameters=&#123;&#125;</span><br><span class="line">2020-09-13 08:19:33 [http-nio-8080-exec-1] WARN  o.s.w.s.PageNotFound(1251) - No mapping <span class="keyword">for</span> GET /index</span><br><span class="line">2020-09-13 08:19:33 [http-nio-8080-exec-1] DEBUG o.s.w.s.DispatcherServlet(1127) - Exiting from <span class="string">&quot;FORWARD&quot;</span> dispatch, status 404</span><br><span class="line">2020-09-13 08:19:33 [http-nio-8080-exec-1] DEBUG o.s.w.s.DispatcherServlet(1131) - Completed 404 NOT_FOUND</span><br></pre></td></tr></table></figure>

<p>결과적으로 우리는 클래스패스에 HTML 파일을 생성하였다고 해서 응답할 수 없습니다.</p>
<h3 id="FreeMarkerViewResolver"><a href="#FreeMarkerViewResolver" class="headerlink" title="FreeMarkerViewResolver"></a>FreeMarkerViewResolver</h3><p>스프링 프레임워크 애플리케이션을 개발하는 대부분의 개발자들은 JSP를 사용해왔습니다. 그러나 최근에는 JSP 보다는 Thymeleaf 또는 FreeMarker 같은 템플릿 엔진을 선호합니다. 그래서 스프링 부트 프로젝트에서는 기본적으로 JSP에 대한 의존성을 지원하지 않고 있습니다. JSP를 원하는 개발자들이 서운해할 수 있지만 프리마커 템플릿 엔진을 사용하여 HTML을 응답해보도록 하겠습니다.</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/javadoc-api/org/springframework/web/servlet/view/freemarker/FreeMarkerViewResolver.html"><code>FreeMarkerViewResolver</code></a>는 <code>FreeMarkerView</code> 클래스를 뷰로 응답할 수 있도록 지원합니다. 즉, 프리마커 템플릿 엔진을 사용하여 웹 요청을 HTML 형식으로 응답할 수 있게 되는 것입니다.</p>
<p>먼저, 프리마커 템플릿 엔진을 사용하기 위해 <a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/org.freemarker/freemarker/2.3.30"><code>freemarker</code></a>와 <code>spring-context-support</code> 의존성을 추가합니다.</p>
<figure class="highlight groovy"><figcaption><span>build.gradle</span></figcaption><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.freemarker:freemarker:2.3.30&#x27;</span></span><br><span class="line">implementation <span class="string">&#x27;org.springframework:spring-context-support:5.2.8.RELEASE&#x27;</span></span><br></pre></td></tr></table></figure>

<p>서블릿 컨텍스트 메타정보 클래스에 <code>FreeMarkerViewResolver</code>와 <code>FreeMarkerConfigurer</code>를 빈으로 등록합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.example.demo.controller&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FreeMarkerViewResolver <span class="title">freemarkerViewResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FreeMarkerViewResolver viewResolver = <span class="keyword">new</span> FreeMarkerViewResolver();</span><br><span class="line">        viewResolver.setContentType(<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br><span class="line">        viewResolver.setCache(<span class="keyword">false</span>);</span><br><span class="line">        viewResolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> viewResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FreeMarkerConfigurer <span class="title">freemarkerConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FreeMarkerConfigurer freeMarkerConfigurer = <span class="keyword">new</span> FreeMarkerConfigurer();</span><br><span class="line">        freeMarkerConfigurer.setTemplateLoaderPath(<span class="string">&quot;classpath:/templates/&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> freeMarkerConfigurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제 애플리케이션을 실행하면 FreeMarkerViewResolver와 FreeMarkerConfigurer를 빈으로 등록하는 로그가 출력되었습니다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-09-13 09:36:59 [main] DEBUG o.s.b.f.s.DefaultListableBeanFactory(217) - Creating shared instance of singleton bean &#39;freemarkerViewResolver&#39;</span><br><span class="line">2020-09-13 09:36:59 [main] DEBUG o.s.b.f.s.DefaultListableBeanFactory(217) - Creating shared instance of singleton bean &#39;freemarkerConfig&#39;</span><br><span class="line">2020-09-13 09:36:59 [main] DEBUG o.s.w.s.v.f.FreeMarkerConfigurer(347) - Template loader path [class path resource [templates&#x2F;]] resolved to file path [C:\Users\Mambo\git\spring5\out\production\resources\templates]</span><br></pre></td></tr></table></figure>

<p>이제 <a href="http://localhost:8080에">http://localhost:8080에</a> 대해 웹 요청이 들어오면 <code>/templates/index.html</code>을 <code>FreeMarkerView</code>로 응답하게 됩니다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-09-13 09:38:10 [http-nio-8080-exec-2] DEBUG o.s.w.s.DispatcherServlet(91) - GET &quot;&#x2F;&quot;, parameters&#x3D;&#123;&#125;</span><br><span class="line">2020-09-13 09:38:10 [http-nio-8080-exec-2] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping(414) - Mapped to com.example.demo.controller.HomeController#index(HttpServletRequest, HttpServletResponse)</span><br><span class="line">2020-09-13 09:38:10 [http-nio-8080-exec-2] DEBUG o.s.w.s.v.f.FreeMarkerView(309) - View name &#39;index&#39;, model &#123;&#125;</span><br><span class="line">2020-09-13 09:38:10 [http-nio-8080-exec-2] DEBUG o.s.w.s.v.f.FreeMarkerView(176) - Rendering [index.html]</span><br><span class="line">2020-09-13 09:38:10 [http-nio-8080-exec-2] DEBUG o.s.w.s.DispatcherServlet(1131) - Completed 200 OK</span><br></pre></td></tr></table></figure>

<h4 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h4><p>FreeMarker도 템플릿 엔진이므로 Model에 값을 넣어 표시할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Model model)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제 다음과 같이 Model에 message 속성을 index.html 템플릿에서 사용할 수 있습니다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;ko&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>$&#123;message&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Logging-System"><a href="#Logging-System" class="headerlink" title="Logging System"></a>Logging System</h2><p>스프링 프레임워크는 <a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/org.springframework/spring-jcl"><code>spring-jcl</code></a> 모듈을 통해 <code>SLF4J</code>와 같은 다양한 로깅에 대한 추상화를 지원합니다. 따라서, 스프링 프레임워크 기반의 웹 애플리케이션에서 로그 출력을 위한 기능은 쉽게 적용할 수 있습니다.</p>
<p><code>slf4j-api</code> 의존성을 추가합니다.</p>
<figure class="highlight groovy"><figcaption><span>build.gradle</span></figcaption><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.slf4j:slf4j-api:1.7.30&#x27;</span></span><br><span class="line"><span class="comment">// implementation &#x27;org.slf4j:slf4j-simple:1.7.30&#x27;</span></span><br></pre></td></tr></table></figure>

<p>SLF4J는 로거 추상화로 구현체를 아직 추가하지 않았기 때문에 다음과 같은 로그가 출력됩니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span>월 <span class="number">12</span>, <span class="number">2020</span> <span class="number">4</span>:<span class="number">21</span>:<span class="number">31</span> 오후 org.apache.jasper.servlet.TldScanner scanJars</span><br><span class="line">정보: At least one JAR was scanned <span class="keyword">for</span> TLDs yet contained no TLDs. Enable debug logging <span class="keyword">for</span> <span class="keyword">this</span> logger <span class="keyword">for</span> a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.</span><br><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br></pre></td></tr></table></figure>

<p>가장 기본적인 <code>slf4j-simple</code> 의존성을 추가하면 정상적으로 스프링 프레임워크에 대한 로그가 출력됩니다.</p>
<h3 id="Logback"><a href="#Logback" class="headerlink" title="Logback"></a>Logback</h3><p>slf4j-simple로 출력되는 로그 보다는 <a target="_blank" rel="noopener" href="http://logback.qos.ch/"><code>Logback</code></a>과 같은 SLF4J 구현체를 사용하는 것이 좋습니다.</p>
<p>다음 <code>logback-classic</code> 의존성을 추가합니다.</p>
<figure class="highlight groovy"><figcaption><span>build.gradle</span></figcaption><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;ch.qos.logback:logback-classic:1.2.3&#x27;</span></span><br></pre></td></tr></table></figure>

<p>클래스패스에 <code>logback.xml</code> 파일을 생성하고 로그백으로 로그를 출력하기 위한 설정을 기술합니다.</p>
<figure class="highlight"><figcaption><span>logback.xml</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;appender name=<span class="string">&quot;STDOUT&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %highlight(%-5level) %cyan(%logger&#123;25&#125;\(%line\)) - %msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;root level=<span class="string">&quot;debug&quot;</span>&gt;</span><br><span class="line">        &lt;appender-ref ref=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>이제 애플리케이션을 실행하면 웹 애플리케이션에 대한 로그가 다음과 같이 출력됩니다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-09-12 16:58:11 [main] INFO  o.s.w.s.DispatcherServlet(525) - Initializing Servlet &#39;dispatcher&#39;</span><br><span class="line">2020-09-12 16:58:11 [main] DEBUG o.s.w.c.s.AnnotationConfigWebApplicationContext(596) - Refreshing WebApplicationContext for namespace &#39;dispatcher-servlet&#39;</span><br><span class="line">2020-09-12 16:58:11 [main] DEBUG o.s.w.c.s.AnnotationConfigWebApplicationContext(217) - Registering component classes: [class com.example.demo.config.WebConfig]</span><br><span class="line">2020-09-12 16:58:11 [main] DEBUG o.s.b.f.s.DefaultListableBeanFactory(217) - Creating shared instance of singleton bean &#39;org.springframework.context.annotation.internalConfigurationAnnotationProcessor&#39;</span><br><span class="line">2020-09-12 16:58:11 [main] DEBUG o.s.b.f.s.DefaultListableBeanFactory(217) - Creating shared instance of singleton bean &#39;org.springframework.context.event.internalEventListenerProcessor&#39;</span><br><span class="line">2020-09-12 16:58:11 [main] DEBUG o.s.b.f.s.DefaultListableBeanFactory(217) - Creating shared instance of singleton bean &#39;org.springframework.context.event.internalEventListenerFactory&#39;</span><br><span class="line">2020-09-12 16:58:11 [main] DEBUG o.s.b.f.s.DefaultListableBeanFactory(217) - Creating shared instance of singleton bean &#39;org.springframework.context.annotation.internalAutowiredAnnotationProcessor&#39;</span><br><span class="line">2020-09-12 16:58:11 [main] DEBUG o.s.b.f.s.DefaultListableBeanFactory(217) - Creating shared instance of singleton bean &#39;org.springframework.context.annotation.internalCommonAnnotationProcessor&#39;</span><br><span class="line">2020-09-12 16:58:11 [main] DEBUG o.s.u.c.s.UiApplicationContextUtils(85) - Unable to locate ThemeSource with name &#39;themeSource&#39;: using default [org.springframework.ui.context.support.DelegatingThemeSource@7741507c]</span><br><span class="line">2020-09-12 16:58:11 [main] DEBUG o.s.b.f.s.DefaultListableBeanFactory(217) - Creating shared instance of singleton bean &#39;webConfig&#39;</span><br><span class="line">2020-09-12 16:58:11 [main] DEBUG o.s.b.f.s.DefaultListableBeanFactory(217) - Creating shared instance of singleton bean &#39;homeController&#39;</span><br><span class="line">2020-09-12 16:58:11 [main] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping(351) - 1 mappings in &#39;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&#39;</span><br><span class="line">2020-09-12 16:58:11 [main] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerAdapter(611) - ControllerAdvice beans: none</span><br><span class="line">2020-09-12 16:58:11 [main] DEBUG o.s.w.s.m.m.a.ExceptionHandlerExceptionResolver(294) - ControllerAdvice beans: none</span><br><span class="line">2020-09-12 16:58:11 [main] DEBUG o.s.w.s.DispatcherServlet(542) - enableLoggingRequestDetails&#x3D;&#39;false&#39;: request parameters and headers will be masked to prevent unsafe logging of potentially sensitive data</span><br><span class="line">2020-09-12 16:58:11 [main] INFO  o.s.w.s.DispatcherServlet(547) - Completed initialization in 165 ms</span><br></pre></td></tr></table></figure>

<hr>
<p>이번 글을 통해 스프링 프레임워크 기반의 웹 애플리케이션을 만들고 실행하는 법에 대해서 알게 되었습니다. 스프링 MVC 모듈은 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/web.html#mvc-config"><code>MVC Configuration</code></a>을 위한 클래스를 추가적으로 제공합니다. 다음 글에서는 MVC Configuration을 통해 스프링 프레임워크 기반의 웹 애플리케이션에 대한 기능을 좀 더 확장해보겠습니다.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mambo-dev.github.io/getting-started-spring-framework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/17937604?s=460&v=4">
      <meta itemprop="name" content="Mambo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mambo Docs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/docs/getting-started-spring-framework/" class="post-title-link" itemprop="url">스프링 프레임워크 시작하기</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">작성일</span>

      <time title="Post created: 2020-09-08 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-08T00:00:00Z">2020-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/docs/categories/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EA%B0%80%EC%9D%B4%EB%93%9C/" itemprop="url" rel="index"><span itemprop="name">스프링 프레임워크 가이드</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>본 글은 스프링 프레임워크 Version <code>5.2.8.RELEASE</code> 문서를 기반으로 작성하였습니다.</p>
<p>잠만보와 함께하는 스프링 프레임워크 기반의 웹 애플리케이션 개발 가이드는 스프링 프레임워크에 대하여 얕은 지식을 가지고 있는 잠만보가 스프링 프레임워크를 기반으로 웹 애플리케이션을 만들기 위한 공부 과정임을 알려드립니다.</p>
<p>이 가이드를 통해 만드는 웹 애플리케이션의 목표는 다음과 같습니다.</p>
<ul>
<li>애플리케이션 컨텍스트 개념 잡기</li>
<li>웹 애플리케이션 컨텍스트 구성</li>
<li>임베디드 톰캣으로 웹 애플리케이션 실행</li>
<li>스프링 테스트 모듈을 통한 애플리케이션 기능 테스트</li>
<li>웹 관련 기능 확장</li>
<li>구글 SMTP 서버를 활용한 이메일 발송</li>
<li>반복적인 작업을 수행하는 스케줄링 적용</li>
<li>스프링 JDBC를 활용한 데이터베이스 액세스</li>
<li>스프링 HTTP 요청 클라이언트 활용</li>
<li>스프링 세션을 활용한 사용자 세션 관리 적용</li>
<li>스프링 시큐리티를 활용한 웹 보안 적용</li>
</ul>
<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p><code>스프링 프레임워크</code> 기반의 웹 애플리케이션은 <a target="_blank" rel="noopener" href="https://start.spring.io/"><code>start.spring.io</code></a>를 통해 스프링 부트 프로젝트를 통해 쉽게 만들어볼 수 있습니다. <code>스프링 부트 프로젝트</code>는 스프링 프레임워크 기반의 애플리케이션을 좀 더 쉽게 만들기 위한 하나의 프로젝트로써 기존의 스프링 프레임워크 코어 모듈을 사용하는 <code>스프링 애플리케이션</code>입니다.</p>
<p>스프링 부트 프로젝트로 쉽게 시작할 수는 있지만 우리의 목표는 스프링 프레임워크에서 사용하는 개념에 대하여 알아가면서 스프링 프레임워크 기반의 웹 애플리케이션을 만들어보는 것 입니다. 스프링 프레임워크에 대해서 알아야만 여러분들이 애플리케이션 개발하는데 어려움을 느끼는 부분을 그나마 쉽게 해결할 수 있습니다. </p>
<p>사실 상 스프링 프레임워크를 기반으로 웹 애플리케이션을 개발할 때 설정해야하는 부분이 생각보다 많습니다. 이 부분은 대부분의 스프링 애플리케이션 개발자들이 느끼는 바이며 이로 인해 스프링 부트 프로젝트가 진행되었다고 볼 수 있습니다. 따라서, 여러분들은 스프링 프레임워크를 어느 정도 알게되면 스프링 부트 프로젝트를 기반으로 웹 애플리케이션을 개발하시기를 추천합니다.</p>
<p>이제 우리는 스프링 프레임워크 기반의 애플리케이션에 대한 설정을 진행하기 위해 스프링 프레임워크에서 사용되는 개념에 대해 알아봅니다. 이 가이드를 통해 스프링 프레임워크에서 사용되는 전체적인 개념을 알아볼 순 없지만 스프링 프레임워크 기반의 웹 애플리케이션을 개발하는데 어려움이 없을 정도로만 개념을 잡으려고 합니다.</p>
<blockquote>
<p>스프링 프레임워크에 대한 전체적인 부분은 공식 레퍼런스 또는 잘 정리된 스프링 서적을 참고하시기 바랍니다.<br><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/">https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/</a></p>
</blockquote>
<h2 id="IoC-Container"><a href="#IoC-Container" class="headerlink" title="IoC Container"></a>IoC Container</h2><p>스프링 프레임워크 기반의 애플리케이션은 <code>제어 역전(Inversion of Control)</code>이라는 개념을 통해 애플리케이션이 동작합니다. 스프링 프레임워크는 <code>IoC 컨테이너</code>라는 특수한 컨테이너에 애플리케이션에서 사용되는 클래스를 담아두고 애플리케이션 개발자가 필요할 때 IoC 컨테이너에서 가져와서 사용할 수 있도록 제공합니다.</p>
<p>결국 스프링 프레임워크에서 사용하는 제어 역전이라는 개념은 애플리케이션에서 사용되는 클래스들에 대한 <code>생애 주기</code> 제어를 애플리케이션 개발자가 아닌 IoC 컨테이너가 담당하도록 하는 것이라고 이해할 수 있습니다. 이 특수한 컨테이너에서 관리되는 클래스들을 <code>빈(Bean)</code>, 그리고 이 빈 클래스들을 관리하고 제어를 담당하는 컨테이너를 IoC 컨테이너 또는 <code>빈 팩토리(Bean Factory)</code>라고 말합니다.</p>
<blockquote>
<p><code>org.springframework.beans</code>와 <code>org.springframework.context</code> 패키지에는 스프링 프레임워크 IoC 컨테이너의 기초가 되는 <code>BeanFactory</code>라는 인터페이스를 제공합니다.</p>
</blockquote>
<p>빈 팩토리는 애플리케이션 개발자가 사용하고자 하는 클래스들의 생애 주기를 담당하며 서로 다른 빈 클래스들이 연결하고 있는 의존성을 확인하고 이 의존성을 주입하는 것도 담당합니다. </p>
<blockquote>
<p><code>의존성 주입(Dependency Injection)</code>이라함은 빈 팩토리가 관리하는 <code>빈 클래스의 생성자</code> 또는 <code>팩토리 메소드의 매개변수</code> 그리고 인스턴스가 생성된 이후에 <code>프로퍼티</code>로써 설정되는 것을 말합니다.</p>
</blockquote>
<h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p>스프링 프레임워크는 <code>BeanFactory</code> 인터페이스를 확장하여 다양한 기능을 추가적으로 지원하는 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.2.8.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html"><code>ApplicationContext</code></a> 인터페이스를 제공합니다. 따라서, 스프링 프레임워크 기반의 애플리케이션을 개발할 때는 애플리케이션 컨텍스트를 주로 사용하게 됩니다. 또한, 웹 애플리케이션과 같은 특정 애플리케이션 레이어에서 사용할 수 있도록 애플리케이션 컨텍스트의 서브 인터페이스도 제공합니다. 예를 들어, <code>WebApplicationContext</code> 인터페이스는 <code>getServletContext()</code>함수를 제공하여 웹 애플리케이션에서 사용하는 <code>ServletContext</code>를 가져올 수 있도록 지원합니다.</p>
<p>스프링 프레임워크에서 제공하는 애플리케이션 컨텍스트는 다음과 같이 동작하게 됩니다.<br><img data-src="https://docs.spring.io/spring/docs/current/spring-framework-reference/images/container-magic.png"></p>
<p>애플리케이션에서 요구하는 <code>구성 메타정보</code>와 함께 애플리케이션 컨텍스트가 관리해야하는 빈 클래스들을 제공하면 애플리케이션 컨텍스트와 함께 완전히 구성된 애플리케이션이 준비됩니다. 이때, 애플리케이션 컨텍스트가 참조하는 구성 메타정보는 전통적으로 간단하고 직관적인 XML 형식을 사용하여 기술하였습니다. 그러나 스프링 3.0부터는 자바 코드를 기반으로 구성 메타정보를 기술할 수 있도록 제공하였습니다.</p>
<blockquote>
<p>저는 XML 보다는 자바 코드 기반으로 구성 메타정보를 기술하는 것을 선호하는 편입니다. 자바 코드를 기반으로 작성할 경우 컴파일 단계에서부터 오류를 파악할 수 있다는 장점이 있습니다.</p>
</blockquote>
<h3 id="Java-based-Container-Configuration"><a href="#Java-based-Container-Configuration" class="headerlink" title="Java-based Container Configuration"></a>Java-based Container Configuration</h3><p>애플리케이션에서 사용하는 라이브러리들을 관리하기 위한 의존성 관리도구로 <code>Gradle</code>을 사용하기 위하여 그레이들 프로젝트로 시작합니다. 인텔리제이와 <a target="_blank" rel="noopener" href="https://spring.io/tools">STS</a> 같은 IDE로 쉽게 그레이들 프로젝트를 만들 수 있습니다.</p>
<p>먼저, 스프링 프레임워크의 애플리케이션 컨텍스트를 구성하기 위하여 build.gradle에 <a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/org.springframework/spring-context/5.2.8.RELEASE"><code>spring-context</code></a> 의존성을 추가합니다.</p>
<figure class="highlight groovy"><figcaption><span>build.gradle</span></figcaption><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group <span class="string">&#x27;org.example&#x27;</span></span><br><span class="line">version <span class="string">&#x27;1.0-SNAPSHOT&#x27;</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;org.springframework:spring-context:5.2.8.RELEASE&#x27;</span></span><br><span class="line">    testCompile <span class="attr">group:</span> <span class="string">&#x27;junit&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;junit&#x27;</span>, <span class="attr">version:</span> <span class="string">&#x27;4.12&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>스프링 <code>spring-context</code> 모듈에는 ApplicationContext 인터페이스와 함께 <code>AnnotationConfigApplicationContext</code>라는 구현체를 함께 제공합니다. 이 구현체는 자바 어노테이션 기반으로 구성 메타정보를 작성할 수 있도록 지원하는 애플리케이션 컨텍스트입니다. </p>
<p>AnnotationConfigApplicationContext는 <code>@Configuration</code>과 <code>@Component</code> 그리고 <code>@Bean</code> 어노테이션을 사용하여 애플리케이션 컨텍스트를 구성합니다.</p>
<p>자바 기반의 구성 메타정보는 <code>@Configuration</code>을 선언하여 구성 메타정보 클래스로 기술합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>그리고 다음과 같이 BasicService, SpringApplication을 생성합니다. 그리고 앞서 만들었던 AppConfig 구성 메타정보 클래스를 애플리케이션 컨텍스트를 생성하면서 구성 메타정보로 활용하도록 제공합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicService</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">        BasicService basicService = applicationContext.getBean(BasicService.class);</span><br><span class="line">        System.out.println(basicService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringApplication을 실행해보면 애플리케이션 컨텍스트의 구성 메타정보 클래스에는 어떠한 빈 클래스도 등록하지 않았으므로 다음과 같이 오류가 발생할 것입니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connected to the target VM, address: <span class="string">&#x27;127.0.0.1:14173&#x27;</span>, transport: <span class="string">&#x27;socket&#x27;</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type <span class="string">&#x27;service.BasicService&#x27;</span> available</span><br><span class="line">    at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:<span class="number">352</span>)</span><br><span class="line">    at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:<span class="number">343</span>)</span><br><span class="line">    at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:<span class="number">1127</span>)</span><br><span class="line">    at SpringApplication.main(SpringApplication.java:<span class="number">8</span>)</span><br><span class="line">Disconnected from the target VM, address: <span class="string">&#x27;127.0.0.1:14173&#x27;</span>, transport: <span class="string">&#x27;socket&#x27;</span></span><br></pre></td></tr></table></figure>

<p>이제 구성 메타정보 클래스에 빈을 등록해보도록 하겠습니다. @Configuration가 선언된 구성 메타정보 클래스에 빈 클래스를 등록할 때에는 <code>@Bean</code>을 빈 클래스를 반환하는 함수에 선언합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BasicService <span class="title">basicService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BasicService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다시 SpringApplication을 실행하면 다음과 같이 애플리케이션 컨텍스트로부터 BasicService 유형의 빈 클래스를 가져올 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">service.BasicService@<span class="number">23</span>c30a20</span><br></pre></td></tr></table></figure>

<p>여기서 구성 메타정보 클래스에 빈 클래스를 등록하는 또 다른 방법을 소개하겠습니다. 바로 <code>@ComponentScan</code>과 <code>@Component</code> 어노테이션을 활용하는 것입니다.</p>
<h3 id="CompnentScan"><a href="#CompnentScan" class="headerlink" title="@CompnentScan"></a>@CompnentScan</h3><p>@Configuration를 선언한 클래스에 <code>@CompnentScan</code>을 선언하여 특정 <code>패키지 단위</code>로 빈을 등록할 수 있습니다. @CompnentScan는 지정된 패키지에 속한 클래스에 <code>@Component</code>가 선언되는 경우 현재 구성 메타정보 클래스에 빈으로 포함시키는 특별한 일을 수행합니다.</p>
<p>만약, @Component가 선언된 클래스가 특정 패키지에 있다면 다음과 같이 구성 메타정보 클래스에 직접 빈을 등록하지 않아도 포함됩니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;service&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>그리고 service 패키지에 <code>ConversionService</code>라는 클래스를 만들고 @Component를 선언합니다. 그리고 애플리케이션 컨텍스트로부터 ConversionService 유형의 빈 클래스를 가져옵니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConversionService</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">        ConversionService conversionService = applicationContext.getBean(ConversionService.class);</span><br><span class="line">        System.out.println(conversionService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다음과 같이 정상적으로 ConversionService 유형의 빈 클래스를 가져왔음을 확인합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">service.ConversionService@<span class="number">1</span>c5920df</span><br></pre></td></tr></table></figure>

<p>그레이들을 통해 스프링 의존성을 추가하고 자바 기반의 컨테이너를 구성해보았습니다. 여기까지 내용을 정리해보면 다음과 같습니다.</p>
<ul>
<li>애플리케이션 컨텍스트에서 활용하는 구성 메타정보는 <code>@Configuration</code>을 선언하여 만든다.</li>
<li>@Configuration을 선언한 구성 메타정보 클래스에서 <code>@Bean</code>을 선언하여 빈을 등록할 수 있다.</li>
<li><code>@CompnentScan</code>을 선언하여<code> @Component</code>가 선언된 클래스를 패키지 단위로 빈으로 등록할 수도 있다.</li>
</ul>
<p>이제 우리는 애플리케이션 컨텍스트를 구성하는 것, 구성 메타정보 클래스를 기술하는 것, 빈 클래스를 등록하는 법에 대하여 알게되었습니다. </p>
<h2 id="Additional-Capabilities"><a href="#Additional-Capabilities" class="headerlink" title="Additional Capabilities"></a>Additional Capabilities</h2><p>애플리케이션 컨텍스트는 빈 클래스들을 관리할 뿐만 아니라 추가적인 기능을 제공합니다. 애플리케이션 컨텍스트가 제공하는 추가 기능을 하나씩 다뤄보도록 하겠습니다.</p>
<h3 id="Environment-Abstraction"><a href="#Environment-Abstraction" class="headerlink" title="Environment Abstraction"></a>Environment Abstraction</h3><p>애플리케이션 컨텍스트가 제공하는 첫번째 기능은 환경변수와 같은 프로퍼티를 관리하거나 환경을 구분할 수 있는 프로파일을 지정하는 것입니다. </p>
<h4 id="Profile"><a href="#Profile" class="headerlink" title="@Profile"></a>@Profile</h4><p>@Configuration을 선언한 구성 메타정보 클래스에 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-definition-profiles-java"><code>@Profile</code></a>을 선언하여 애플리케이션 환경을 구분할 수 있습니다. @Profile이 선언된 구성 메타정보에 기술된 빈은 해당 프로파일이 활성화 되어있을 경우 등록됩니다.</p>
<p>앞서 만들었던 AppConfig 클래스에 @Profile을 선언하고 실행합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Profile(&#123;&quot;mambo&quot;&#125;)</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;service&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>프로파일을 지정하면 다음과 같이 애플리케이션 컨텍스트로부터 EventService 빈을 가져올 수 없습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type <span class="string">&#x27;service.EventService&#x27;</span> available</span><br><span class="line">    at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:<span class="number">352</span>)</span><br><span class="line">    at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:<span class="number">343</span>)</span><br><span class="line">    at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:<span class="number">1127</span>)</span><br><span class="line">    at SpringApplication.main(SpringApplication.java:<span class="number">9</span>)</span><br></pre></td></tr></table></figure>

<p>애플리케이션 컨텍스트가 참조하는 Environment에 프로파일을 지정할 수 있도록 약간 수정합니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        ConfigurableEnvironment environment = applicationContext.getEnvironment();</span><br><span class="line">        environment.setActiveProfiles(<span class="string">&quot;mambo&quot;</span>);</span><br><span class="line">        applicationContext.register(AppConfig.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        EventService eventService = applicationContext.getBean(EventService.class);</span><br><span class="line">        System.out.println(eventService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>mambo라는 프로파일을 지정하였기에 다음과 같이 EventService 빈을 가져올 수 있게 됩니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">service.EventService@<span class="number">4</span>ef74c3</span><br></pre></td></tr></table></figure>

<h4 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h4><p>Environment 인터페이스를 통해 애플리케이션에서 사용하는 환경변수인 프로퍼티를 관리할 수 있습니다. <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-using-propertysource"><code>@PropertySource</code></a>는 구성 메타정보 클래스에 선언되어 <code>.properties</code> 파일에 기술된 프로퍼티 정보를 Environment에 주입할 수 있도록 지원합니다.</p>
<p>다음과 같이 클래스패스에 application.properties 파일을 생성하여 프로퍼티를 기술합니다.</p>
<figure class="highlight properties"><figcaption><span>application.properties</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">SpringApplication</span></span><br></pre></td></tr></table></figure>

<p>그리고 @PropertySource를 선언하여 application.properties 파일을 지정하고 Environment를 통해 프로퍼티를 가져와봅니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&#123;&quot;classpath:application.properties&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Profile(&#123;&quot;mambo&quot;&#125;)</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;service&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        ConfigurableEnvironment environment = applicationContext.getEnvironment();</span><br><span class="line">        environment.setActiveProfiles(<span class="string">&quot;mambo&quot;</span>);</span><br><span class="line">        applicationContext.register(AppConfig.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        String property = environment.getProperty(<span class="string">&quot;spring.application.name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;property: &quot;</span>+ property);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다음과 같이 프로퍼티 파일에 기술한 프로퍼티를 가져올 수 있게 되었습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">property: SpringApplication</span><br></pre></td></tr></table></figure>

<h3 id="Internationalization"><a href="#Internationalization" class="headerlink" title="Internationalization"></a>Internationalization</h3><p>애플리케이션 컨텍스트가 제공하는 또 다른 기능은 메시지 소스를 관리하는 것입니다. <code>MessageSource</code> 인터페이스는 <code>i8n</code>이라고 하는 국제화 기능을 지원합니다. 애플리케이션 컨텍스트가 실행될 때 구성 메타정보에 선언된 <code>MessageSource</code> 유형의 빈을 자동으로 찾아 메시지 소스로 등록하게 되어있습니다.</p>
<p>스프링 프레임워크는 <code>ResourceBundleMessageSource</code>와 같은 MessageSource 구현체를 제공합니다. 대부분의 스프링 프레임워크 기반의 애플리케이션은 ResourceBundleMessageSource를 메시지 소스로 등록하여 사용하며 이 구현체에 대한 대안으로 <code>핫 리로드</code>를 지원하는 <code>ReloadableResourceBundleMessageSource</code>도 있습니다.</p>
<p>메시지 소스로 관리할 메시지가 포함되어있는 messages.properties 파일을 클래스패스에 추가합니다.</p>
<figure class="highlight properties"><figcaption><span>messages.properties</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">argument.required</span>=<span class="string">The &#123;0&#125; argument is required.</span></span><br></pre></td></tr></table></figure>

<p>구성 메타정보 클래스에 ResourceBundleMessageSource를 빈으로 등록합니다. 이때, <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/support/AbstractResourceBasedMessageSource.html#setBasenames-java.lang.String...-">setBasenames</a> 함수를 사용하여 클래스패스에 있는 messages*.properties를 찾아 메시지 소스로 등록하도록 합니다. </p>
<p>ResourceBundleMessageSource는 setBasenames에 지정된 이름으로 시작하는 리소스들을 불러와서 메시지로 저장합니다. 예를 들어, <code>messages.properties</code>, <code>messages_ko.properties</code>, <code>messages_en.properties</code>와 같이 언어별로 메시지를 구분할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&#123;&quot;classpath:application.properties&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Profile(&#123;&quot;mambo&quot;&#125;)</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;service&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageSource <span class="title">messageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ResourceBundleMessageSource messageSource = <span class="keyword">new</span> ResourceBundleMessageSource();</span><br><span class="line">        messageSource.setBasenames(<span class="string">&quot;messages&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> messageSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그리고 애플리케이션 컨텍스트에서 메시지 소스에 등록된 메시지를 가져올 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        ConfigurableEnvironment environment = applicationContext.getEnvironment();</span><br><span class="line">        environment.setActiveProfiles(<span class="string">&quot;mambo&quot;</span>);</span><br><span class="line">        applicationContext.register(AppConfig.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        String message = applicationContext.getMessage(<span class="string">&quot;argument.required&quot;</span>, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;username&quot;</span>&#125;, Locale.getDefault());</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다음과 같이 메시지의 {0}부분이 매개변수 “username”로 치환하여 제공하였습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">The username argument is required.</span><br></pre></td></tr></table></figure>

<h3 id="Access-Resources"><a href="#Access-Resources" class="headerlink" title="Access Resources"></a>Access Resources</h3><p>애플리케이션 컨텍스트는 <code>ResourceLoader</code> 인터페이스를 통하여 <code>Resource</code> 오브젝트를 불러올 수도 있습니다. Resource는 클래스패스, 파일 시스템, 표준 URL등 다양한 방식으로 로우-레벨의 리소스를 가져올 수 있습니다.</p>
<p>클래스패스에 README.md 파일을 만들고 애플리케이션 컨텍스트로부터 파일을 가져와보겠습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        ConfigurableEnvironment environment = applicationContext.getEnvironment();</span><br><span class="line">        environment.setActiveProfiles(<span class="string">&quot;mambo&quot;</span>);</span><br><span class="line">        applicationContext.register(AppConfig.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Resource resource = applicationContext.getResource(<span class="string">&quot;classpath:README.md&quot;</span>);</span><br><span class="line">            String readme = StreamUtils.copyToString(resource.getInputStream(), StandardCharsets.UTF_8);</span><br><span class="line">            System.out.println(readme);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다음과 같이 <code>README.md</code> 파일 내용이 출력되었습니다. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">An application context is a ResourceLoader, which can be used to load Resource objects.</span><br></pre></td></tr></table></figure>

<h3 id="Event-Publication"><a href="#Event-Publication" class="headerlink" title="Event Publication"></a>Event Publication</h3><p>애플리케이션 컨텍스트는 <code>ApplicationEventPublisher</code> 인터페이스를 통하여 컨테이너에 존재하는 빈들에게 이벤트를 발행할 수 있습니다. 그리고 빈 클래스에서 <code>@EventListener</code>를 선언한 메소드에서 애플리케이션 컨텍스트가 발행한 이벤트를 수신하여 처리할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        ConfigurableEnvironment environment = applicationContext.getEnvironment();</span><br><span class="line">        environment.setActiveProfiles(<span class="string">&quot;mambo&quot;</span>);</span><br><span class="line">        applicationContext.register(AppConfig.class);</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        applicationContext.publishEvent(<span class="string">&quot;Published!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>애플리케이션 컨텍스트를 통해 이벤트를 발행하였습니다. 이제 해당 이벤트를 수신하기 위하여 @EventListener를 선언한 메소드를 만듭니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">        <span class="comment">// Published!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>앞선 예제 코드에서는 String 유형의 메시지를 발행하였으나 특정 빈 클래스들이 이벤트를 수신하여 처리할 수 있도록 이벤트 오브젝트를 만들어 발행할 수 있습니다. 예를 들어, 애플리케이션 컨텍스트의 <code>start()</code> 함수를 호출하면 <code>ContextStartedEvent</code> 이벤트가 발행됩니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">applicationContext.start();</span><br><span class="line"></span><br><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startUp</span><span class="params">(ContextStartedEvent startedEvent)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Context started : &quot;</span> + startedEvent.getSource());</span><br><span class="line">    <span class="comment">// Context started : org.springframework.context.annotation.AnnotationConfigApplicationContext@51cdd8a, started on Thu Sep 10 23:48:00 KST 2020</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Aware"><a href="#Aware" class="headerlink" title="Aware"></a>Aware</h2><p>Aware 인터페이스는 빈 클래스가 사용되는 시점에 Setter 기반의 의존성을 주입할 수 있도록 제공합니다. 스프링 프레임워크는 기본적으로 제공하는 *Aware 인터페이스가 있습니다. 스프링 프레임워크에 포함된 대부분의 클래스들도 이 Aware 인터페이스를 포함하고있습니다.</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/ApplicationContextAware.html"><code>ApplicationContextAware</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/EnvironmentAware.html"><code>EnvironmentAware</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/ResourceLoaderAware.html"><code>ResourceLoaderAware</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/MessageSourceAware.html"><code>MessageSourceAware</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/context/ServletContextAware.html"><code>ServletContextAware</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/quartz/SchedulerContextAware.html"><code>SchedulerContextAware</code></a></li>
</ul>
<p>ServletContextAware와 SchedulerContextAware와 같은 인터페이스는 특정한 애플리케이션 컨텍스트 또는 특정 인터페이스 구현체에서만 의존성을 주입할 수 있습니다.</p>
<hr>
<p>스프링 프레임워크 기반의 애플리케이션을 만들기 위해서 IoC 컨테이너인 애플리케이션 컨텍스트를 구성하고 애플리케이션 컨텍스트가 제공하는 여러가지 기능에 대하여 알아보았습니다. 스프링 프레임워크는 웹 애플리케이션을 개발할 수 있도록 <code>WebApplicationContext</code>라는 확장된 애플리케이션 컨텍스트를 제공합니다. </p>
<p>다음 글에서는 웹 애플리케이션 컨텍스트를 활용하여 <a href="../building-web-application-with-spring-framework">스프링 프레임워크 기반의 웹 애플리케이션</a>을 만들어보는 시간을 가지겠습니다. </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/docs/"><i class="fa fa-angle-left" aria-label="이전 페이지"></i></a><a class="page-number" href="/docs/">1</a><span class="page-number current">2</span>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
      <aside class="adsense-block">
        <div class="adsense-block-wrapper">
          <!-- AdSense Display -->
          <ins class="adsbygoogle"
              style="display:block"
              data-ad-client="ca-pub-9304279418886145"
              data-ad-slot="3137426518"
              data-ad-format="auto"
              data-full-width-responsive="true"></ins>
          <script>
              (adsbygoogle = window.adsbygoogle || []).push({});
          </script>
        </div>
      </aside>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mambo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js"></script>
<script src="/docs/js/utils.js"></script><script src="/docs/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  






  



    <div class="pjax">


    </div>
</body>
</html>
